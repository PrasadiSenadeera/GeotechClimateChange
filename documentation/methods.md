# Methods

We structured our app as indicated in the following figure:
![alt text](figures/workflow.png?raw=true)

The root script of our app, which is needed to execute to run the application is structured in three blocks. First, it calls the preprocessing (backend) module, then calls the layout and callback module (frontend), and finally runs the app. This script is available in [app.py](https://github.com/carlesmila/GeotechClimateChange/blob/master/app.py). In the following subsections each of these steps will be explained in detail.

## Backend

The first step in the backend is to check whether a cache for the app exists, i.e. whether a sqlite with the data needed to run the app exists. If the answer this logical operation is positive, then all preprocessing (backend) modules are skipped and we jump into the frontend definition. If, however, it is not, they do need to be run. The motivation behind the cache is to avoid unnecessary processing when running the app while also considering updates in the database when new data are available. The cache check code is available in the first part of [CheckCachePreprocess.py](https://github.com/carlesmila/GeotechClimateChange/blob/master/CheckCachePreprocess.py) script.

The first step of the preprocessing is to prepare the temperature data to be used in the app. The most important steps in this module are to read the temperature in the raw NetCDF file and transform it to a pandas data frame, fix the longitudes to correspond to a WGS1984 coordinate reference system, compute pixel-level temperature yearly averages from the monthly data, to calculate the pixel-level temperature baseline (mean temperature between 1948-1952) and compute the pixel-level difference between temperature in a given year and baseline. The resulting data are stored in a pandas data frame indexed by the pixel coordinates and year (i.e. one row per pixel per year). Furthermore, the pixel-level linear trend is computed as a linear regression model (temperature~time) and the values of the estimated intercepts and slopes are saved in an additional pandas table indexed by the pixel coordinates (i.e. one row per pixel), although we did not use these data in the current version of the app. The module in charge of the temperature preprocessing is available in [PreprocessTemp.py](https://github.com/carlesmila/GeotechClimateChange/blob/master/PreprocessTemp.py). 

The same steps are also performed for precipitable water, except for the fact that yearly pixel-level sums were extracted for the monthly data rather than yearly pixel-based means. The precipatable water preprocessing module is available in [PreprocessPrecip.py](https://github.com/carlesmila/GeotechClimateChange/blob/master/PreprocessPrecip.py). Both temperature and precipitable water preprocessing use the same functions for longitude correction and linear trend extraction, which we define in an additional utils module that can be consulted in [PreprocessUtils.py](https://github.com/carlesmila/GeotechClimateChange/blob/master/PreprocessUtils.py).

The next step is to extract time-invariant additional information at the pixel level, namely the country and climate that correspond to each pixel. To do so, the coordinate grid is converted into a geopandas object, and we perform spatial join to extract the country names and climate zone using auxiliary polygon data. For areas with no country/climate area, the pixel is labelled to be water body. The resulting data is stored in a pandas dataframe indexed by the pixel coordinates (i.e. one row per pixel). The code of this model is available in the [PreprocessCommon.py](https://github.com/carlesmila/GeotechClimateChange/blob/master/PreprocessCommon.py) script.

The last step in the preprocessing is to group all the data into two different pandas tables by joining tables. The first table is called TEMPTAB and is indexed by the pixel coordinates (lon, lat) and time, and contains temperature, precipitable water, and deviations from the respective baselines. The second table is called FIXEDTAB and is indexed by the coordinates (lon, lat), and contains the country, climate area, and temperature and precipitable water of each pixel. These two tables are then stored into an sqlite database that will be read in the frontend. This module is available in the last part of the [CheckCachePreprocess.py](https://github.com/carlesmila/GeotechClimateChange/edit/master/documentation/methods.md) script.

## Frontend

Link to frontend is in [DefineApp.py](https://github.com/carlesmila/GeotechClimateChange/blob/master/DefineApp.py).

## Deployment

The application was deployed using PythonAnywhere, an online development and web hosting service that uses Python programming language. Within the PythonAnywhere webpage, it is possible to create a virtual environment using Python version 3.7 (or other version) and install all the dependencies the application requires to run. The Python Web Framework used for this app was Flask. After uploading all files (data and codes) to the website platform, the working directory was set as well as the server details through the Web Server Gateway Interface (WSGI) configuration file.

Initially, we tried to deploy the application using the cloud platform Heroku (and its command line interface), which supports many programming languages including Python, Java, Node.js, Scala and PHP. However, after performing the required steps to deploy the app and make it available online, Heroku presented an unexpected error related to memory quota consumption even though the application was not big. The source of this error was not tracked, and this solution could not be adopted for this project.
